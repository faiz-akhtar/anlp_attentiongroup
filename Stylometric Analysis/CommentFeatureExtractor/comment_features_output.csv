code,language,generator,label,comment_comment_density,comment_inline_comment_density,comment_block_comment_density,comment_docstring_density,comment_function_comment_coverage,comment_class_comment_coverage,comment_comment_clustering_coefficient,comment_avg_comment_distance,comment_comment_position_variance,comment_header_comment_ratio,comment_avg_comment_length,comment_comment_length_std,comment_max_comment_length,comment_min_comment_length,comment_median_comment_length,comment_comment_to_code_ratio,comment_end_of_line_ratio,comment_standalone_comment_ratio,comment_indentation_consistency,comment_comment_code_alignment_score,comment_proximity_to_complexity_score,comment_avg_words_per_comment,comment_sentence_completeness_ratio,comment_personal_pronoun_ratio,comment_technical_term_density,comment_redundancy_score,comment_abstraction_level_score,comment_docstring_format_compliance,comment_todo_fixme_ratio,comment_external_reference_ratio,comment_ascii_art_ratio,comment_comment_hierarchy_score,comment_temporal_marker_ratio,comment_sentiment_polarity_avg,comment_sentiment_polarity_std,comment_semantic_consistency_score,comment_explanation_depth_score,comment_code_comment_similarity_avg
"
def calculate_fibonacci(n):
    """"""
    Calculate the nth Fibonacci number using dynamic programming.
    
    Args:
        n (int): The position in the Fibonacci sequence
        
    Returns:
        int: The nth Fibonacci number
        
    Raises:
        ValueError: If n is negative
    """"""
    if n < 0:
        raise ValueError(""n must be non-negative"")  # Input validation
    
    # Base cases
    if n <= 1:
        return n
    
    # Dynamic programming approach for efficiency
    dp = [0] * (n + 1)
    dp[1] = 1
    
    # Fill the dp array
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]  # Fibonacci recurrence
    
    return dp[n]
            ",python,human,0,0.1935483870967742,0.10526315789473684,0.0,0.03225806451612903,1.0,1.0,0.5495242034244882,-2.6,0.07021042895132384,0.16666666666666666,63.666666666666664,91.07994046745725,266.0,12.0,20.5,0.276410998552822,0.3333333333333333,0.6666666666666667,1.0,1.0,0.5984848484848485,7.333333333333333,0.0,0.5686274509803921,0.0196078431372549,0.25,1.0,1.0,0.0,0.0,0.8333333333333334,0.75,0.0,-0.15833333333333335,0.2921424690493018,0.008474747474747475,0.03333333333333333,0.775
"
public class QuickSort {
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = (low - 1);
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        
        return i + 1;
    }
}
            ",java,llm_gpt4,1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
"
# Machine learning model for text classification
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.pipeline import Pipeline

class TextClassifier:
    def __init__(self):
        # Initialize the classification pipeline
        self.pipeline = Pipeline([
            ('tfidf', TfidfVectorizer(stop_words='english', max_features=10000)),
            ('classifier', MultinomialNB(alpha=1.0))
        ])
        self.is_trained = False
    
    def train(self, texts, labels):
        # Train the model on the provided data
        self.pipeline.fit(texts, labels)
        self.is_trained = True
    
    def predict(self, texts):
        # Make predictions on new texts
        if not self.is_trained:
            raise ValueError(""Model must be trained before making predictions"")
        return self.pipeline.predict(texts)
            ",python,human,0,0.14814814814814814,0.0,0.0,0.0,0.0,0.0,0.8319256396465603,7.0,0.08736282578875171,0.5,39.25,6.057020719792859,48.0,31.0,39.0,0.13569576490924806,0.0,1.0,0.2240092377397959,1.0,0.6666666666666666,5.5,0.0,0.6923076923076923,0.07692307692307693,0.2272727272727273,0.0,0.0,0.0,0.0,1.0,0.25,0.0,0.03409090909090909,0.05904718662166627,0.06885521885521885,0.0,0.3148148148148148
